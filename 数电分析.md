# 数电作业-1
---
## 所有仿真图结果
![alt text](image.png)
![alt text](image-1.png)
![alt text](image-2.png)
![alt text](image-3.png)
![alt text](003687da0541d1093b04cfca5812a491.png)
---
## 简要分析
### 1.4-2编码器：
我们可以列出4-2编码器的真值表
| $I_3$ | $I_2$ | $I_1$ | $I_0$ | $A$ | $B$ |
| --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | **1** | 0 | 0 |
| 0 | 0 | **1** | 0 | 0 | **1** |
| 0 | **1** | 0 | 0 | **1** | 0 |
| **1** | 0 | 0 | 0 | **1** | **1** |

很显然，我们可以根据真值表，写出其布尔代数表达式：
$$
\left\{
\begin{aligned}
A &= I_2 + I_3 \\
B &= I_1 + I_3
\end{aligned}
\right.
$$
从这表看出，其实$I_0$没有被用到。由于这是一个很简单的式子，其VHDL可以被很好地写出来。
![alt text](image-4.png)
## 2.2-4译码器：
同样地，我们可以列出2-4译码器的真值表：
| $A$ | $B$ | $Y_3$ | $Y_2$ | $Y_1$ | $Y_0$ |
| --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 | **1** |
| 0 | **1** | 0 | 0 | **1** | 0 |
| **1** | 0 | 0 | **1** | 0 | 0 |
| **1** | **1** | **1** | 0 | 0 | 0 |

由图可知$Y_0$只能在$A,B$都为0时为1，所以
$$Y_0=\bar{A} \cdot \bar{B}$$
类似的
$$Y_3=A \cdot {B}$$
对于$Y_1$,我们一时不好判断，可以列真值表，画卡诺图来分析
|           | $B = 0$ | $B = 1$ |
| --- | --- | --- |
| $A = 0$ | 0 | **1** |
| $A = 1$ | 0 | 0 |

所以:
$$Y_1=\bar{A} \cdot B$$
类似的
$$Y_2 = A \cdot \bar{B}$$
所以，我们有：
$$
\left\{
\begin{aligned}
Y_0 &= \bar{A} \cdot \bar{B} \\
    Y_1 &= \bar{A} \cdot B \\
    Y_2 &= A \cdot \bar{B} \\
    Y_3 &= A \cdot B
\end{aligned}
\right.
$$
## 3.数据选择器
数据选择器的逻辑是，通过一个信号的有无，来输出对应的信号
所以，我们有：
$$Y = (D_0 \cdot \bar{S}) + (D_1 \cdot S)$$
## 4.全加器
全加器不仅要考虑本位的两个加数 $A$ 和 $B$，还要考虑低位进上来的进位 $C_{in}$。


### 4.1 真值表与逻辑分析
我们可以列出全加器的真值表：

| $A$ | $B$ | $C_{in}$ | $S$ | $C_{out}$ |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

### 4.2 布尔代数推导（对应代码逻辑）


1.  **第一级半加器 (处理 A 和 B):**
    *   中间和 `h_sum1`：$A \oplus B$
    *   中间进位 `h_carry1`：$A \cdot B$

2.  **第二级半加器 (处理 h_sum1 和 Cin):**
    *   最终和 `Sum`：`h_sum1` $\oplus C_{in}$ $\Rightarrow$ **$A \oplus B \oplus C_{in}$**
    *   第二级进位 `h_carry2`：`h_sum1` $\cdot C_{in}$ $\Rightarrow$ $(A \oplus B) \cdot C_{in}$

3.  **最终进位输出:**
    *   只要第一级或第二级产生进位，最终结果就有进位。
    *   `Cout`：`h_carry1` + `h_carry2` $\Rightarrow$ **$A \cdot B + (A \oplus B) \cdot C_{in}$**

这与全加器的标准逻辑完全一致，且比直接写标准“与或式”更节省逻辑门资源。

### 4.3 VHDL 实现
    -- === 第 1 个半加器 (计算 A+B 的本位和与进位) ===
    h_sum1   <= A xor B;    
    h_carry1 <= A and B;    

    -- === 第 2 个半加器 (加上低位进位 Cin) ===
    Sum      <= h_sum1 xor Cin; 
    h_carry2 <= h_sum1 and Cin; 

    -- === 最后的或门 (汇总进位信号) ===
    Cout     <= h_carry1 or h_carry2;
***

### 4.4 全加器卡诺图化简推导

我们需要通过卡诺图分析，推导出全加器的输出表达式：
$$
\left\{
\begin{aligned}
S &= A \oplus B \oplus C_{in} \\
C_{out} &= (A \cdot B) + (A \oplus B) \cdot C_{in}
\end{aligned}
\right.
$$

### 4.4.1 本位和 $S$ 的推导

首先列出 $S$ 的卡诺图（$S$ 为1的情况是输入的1的个数为奇数）：

| $C_{in} \setminus AB$ | 00 | 01 | 11 | 10 |
| :---: | :---: | :---: | :---: | :---: |
| **0** | 0 | **1** | 0 | **1** |
| **1** | **1** | 0 | **1** | 0 |

**分析步骤：**
1.  **观察分布**：我们可以看到 $1$ 的分布呈“棋盘格”状，这意味着没有任何相邻的 $1$ 可以圈在一起进行消去化简。
2.  **写出最小项表达式**：必须把这4个 $1$ 单独写出来：
    $$S = \bar{A}\bar{B}C_{in} + \bar{A}B\bar{C}_{in} + ABC_{in} + A\bar{B}\bar{C}_{in}$$
3.  **代数变换**：虽然卡诺图无法直接化简，但我们可以通过提取公因式将其转换为异或形式。
    *   提取 $C_{in}$ 和 $\bar{C}_{in}$：
        $$S = C_{in}(\bar{A}\bar{B} + AB) + \bar{C}_{in}(\bar{A}B + A\bar{B})$$
    *   识别异或与同或逻辑：
        *   $\bar{A}B + A\bar{B} = A \oplus B$
        *   $\bar{A}\bar{B} + AB = \overline{A \oplus B}$ (同或)
    *   令 $X = A \oplus B$，则上式变为：
        $$S = C_{in}\bar{X} + \bar{C}_{in}X$$
    *   这正是 $C_{in}$ 和 $X$ 的异或逻辑：
        $$S = X \oplus C_{in} = (A \oplus B) \oplus C_{in}$$

### 4.4.2 进位输出 $C_{out}$ 的推导

列出 $C_{out}$ 的卡诺图（$C_{out}$ 为1的情况是输入的1的个数 $\ge 2$）：

| $C_{in} \setminus AB$ | 00 | 01 | 11 | 10 |
| :---: | :---: | :---: | :---: | :---: |
| **0** | 0 | 0 | **1** | 0 |
| **1** | 0 | **1** | **1** | **1** |

**分析步骤：**
我们采用**特定分组法**：

1.  **圈组1（$A \cdot B$）**：
    圈出 $AB=11$ 这一列的两个 $1$。
    $$Term_1 = A \cdot B$$

2.  **处理剩余的 $1$**：
    剩下位于 $(0, 1, 1)$ 和 $(1, 0, 1)$ 的两个 $1$ 没有被完全覆盖。虽然我们可以和中间的 $1$ 组成圈，但为了凑出 $A \oplus B$，我们直接观察这两个位置：
    *   位置 $(0, 1, 1)$ 对应：$\bar{A} B C_{in}$
    *   位置 $(1, 0, 1)$ 对应：$A \bar{B} C_{in}$
    *   提取 $C_{in}$：$(\bar{A}B + A\bar{B}) \cdot C_{in}$
    *   转换为异或：$(A \oplus B) \cdot C_{in}$

3.  **合并结果**：
    $$C_{out} = (A \cdot B) + (A \oplus B) \cdot C_{in}$$

**总结：**
通过这种特定的分组方式，我们不仅完成了逻辑覆盖，而且复用了 $S$ 计算中已经产生的 $A \oplus B$ 信号，从而节省了硬件门电路资源（这就是“两个半加器+一个或门”的理论依据）。

## 5.1位数值比较器
1位数值比较器的功能是比较两个1位二进制数 $A$ 和 $B$ 的大小。输出通常有三个信号，分别代表 $A>B$、$A<B$ 和 $A=B$。
我们可以列出真值表如下：
| $A$ | $B$ | $Y(A>B)$ | $Y(A<B)$ | $Y(A=B)$ |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | 0 | **1** |
| 0 | **1** | 0 | **1** | 0 |
| **1** | 0 | **1** | 0 | 0 |
| **1** | **1** | 0 | 0 | **1** |

分析真值表：
1. **$A>B$ 的情况**：只有当 $A=1$ 且 $B=0$ 时，输出为1。
$$Y(A>B) = A \cdot \bar{B}$$
2. **$A<B$ 的情况**：只有当 $A=0$ 且 $B=1$ 时，输出为1。
$$Y(A<B) = \bar{A} \cdot B$$
3. **$A=B$ 的情况**：当 $A, B$ 同时为0或同时为1时，输出为1。这实际上是同或运算（异或非）。
$$Y(A=B) = \bar{A} \cdot \bar{B} + A \cdot B = \overline{A \oplus B}$$

所以，我们有：
$$
\left\{
\begin{aligned}
Y(A>B) &= A \cdot \bar{B} \\
Y(A<B) &= \bar{A} \cdot B \\
Y(A=B) &= \overline{A \oplus B}
\end{aligned}
\right.
$$
